module au_top (
    input clk,              // 100MHz clock
    input rst_n,            // reset button (active low)
    
    input usb_rx,           // USB->Serial input
    output usb_tx,          // USB->Serial output
    output io_sel [4],      // Digit select on IO Shield
    output io_seg [8],      // 7-segment LEDs on IO Shield
    /*output led [8],         // 8 user controllable LEDs
    output io_led [24],   // LEDs on IO Shield
    input io_button [5],    // 5 buttons on IO Shield
    input io_dip [24],     // DIP switches on IO Shield
    */ //I don't think we're using the 
    // our custom inputs go here
    input p1button[5],
    input p2button[5],
    output p1win_led,
    output p2win_led,
    output p1pattern[9],
    output p1pos[9],
    output p2pos[9],
    output p2pattern[9],
    output pattern[9]
    /* these values are a little different from normal as we're using a self-modified version of io.acf*/
  ) {
  
  sig rst;                  // reset signal
  
  .clk(clk) {
    // The reset conditioner is used to synchronize the reset signal to the FPGA
    // clock. This ensures the entire FPGA comes out of reset at the same time.
    reset_conditioner reset_cond;
    
    .rst(rst){
      //initialise all the dffs needed to store values
      dff register_a[16];
      dff register_b[16];
      dff register_alufn[6];
      dff register_result[16];
      dff register_z;
      dff register_v;
      dff register_n;
      //For automatic mode
      dff register_correct[16];
      dff register_status[8];
      dff counter[29];
      dff case_state[4](#INIT(0));
      
      //TODO: initialise the FSM and all states needed to run the game
      //fsm statemachine = {};
      
      multi_seven_seg seg;  
    }
  }
  
  alu alutop; // instantiate our alu
  const TIMER = 28;
  
  sig a[16]; // instantiate all other top-level stuff
  sig b[16];
  sig alu[16];
  sig alufn[6];
  
  always {
    reset_cond.in = ~rst_n; // input raw inverted reset signal
    rst = reset_cond.out;   // conditioned reset
    
    usb_tx = usb_rx;        // loop serial port
    
    p1win_led = 0;
    p2win_led = 0; // initialise p1 and p2 winning LEDs
    
    pattern = 9b0; // initialise the winning pattern TODO: put in the first pattern
    p1pos = b000000001; // initialise player 1 and player 2 pos to top-left
    p2pos = b000000001;
    
    p1pattern = 9b0; //all OFF
    p2pattern = 9b0;
    
    
    io_seg = 8hff;          // turn segments off
    io_sel = 4hf;           // select no digits
    
    seg.values = {8hf, 8hf, 8hf, 8hf}; // 7 seg display initialised but shows nothing
    
    a = 16b0; //instantiate values
    b = 16b0;
    io_seg = ~seg.seg;
    io_sel = ~seg.sel;
  
    alutop.a = a;
    alutop.b = b;
    alufn = 6b0;
    alutop.alufn = alufn;
    alu = alutop.result; // bind the result of alutop to alu
     
    
}