module au_top (
    input clk,              // 100MHz clock
    input rst_n,            // reset button (active low)
    output led [8],         // 8 user controllable LEDs
    input usb_rx,           // USB->Serial input
    output usb_tx,          // USB->Serial output
    output io_led [24],   // LEDs on IO Shield
    output io_seg [8],      // 7-segment LEDs on IO Shield
    output io_sel [4],      // Digit select on IO Shield
    input io_button [5],    // 5 buttons on IO Shield
    input io_dip [24]     // DIP switches on IO Shield
    /* these values are a little different from normal as we're using a self-modified version of io.acf*/
  ) {
  
  sig rst;                  // reset signal
  
  .clk(clk) {
    // The reset conditioner is used to synchronize the reset signal to the FPGA
    // clock. This ensures the entire FPGA comes out of reset at the same time.
    reset_conditioner reset_cond;
    
    .rst(rst){
      //initialise all the dffs needed to store values
      dff register_a[16];
      dff register_b[16];
      dff register_alufn[6];
      dff register_result[16];
      dff register_z;
      dff register_v;
      dff register_n;
      //For automatic mode
      dff register_correct[16];
      dff register_status[8];
      dff counter[29];
      dff case_state[4](#INIT(0));
      
      //TODO: initialise the FSM and all states needed for both manual inputs and automatic test cases
      fsm statemachine = {INITIAL, MANUAL, ADDER, ADDEROV, COMPAREEQ, COMPARELT, BOOLAND, BOOLXNOR, SHIFTLEFT, SHIFTRIGHTA, SHOWB, NOTA, MULTIPLY};
      
      multi_seven_seg seg;  
    }
  }
  
  alu alutop; // instantiate our alu
  const TIMER = 28;
  
  sig a[16]; // instantiate all other top-level stuff
  sig b[16];
  sig alu[16];
  sig alufn[6];
  
  always {
    reset_cond.in = ~rst_n; // input raw inverted reset signal
    rst = reset_cond.out;   // conditioned reset
    
    usb_tx = usb_rx;        // loop serial port
    
    led = 8h00;             // turn LEDs off
    
    io_led = 24h00;    // turn LEDs off
    io_seg = 8hff;          // turn segments off
    io_sel = 4hf;           // select no digits
    
    seg.values = {8hf, 8hf, 8hf, 8hf}; // 7 seg display initialised but shows nothing
    a = 16b0; //instantiate values
    b = 16b0;
    io_seg = ~seg.seg;
    io_sel = ~seg.sel;
    
    alufn = io_dip[21:16];
    alutop.alufn = alufn; // bind the input of the switches to alufn inputs
    io_led[15:0] = a;
    alutop.a = a;
    alutop.b = b;
    alu = alutop.result; // bind the result of alutop to alu
     
    // all bindings complete for initialisation
    // todo: allow for manual input OR run test cases upon button press
    
    // initial state
    case(statemachine.q){
      statemachine.INITIAL:
        seg.values = {8hf, 8hf, 8hf, 8hf};
        
        if(io_button[4]==1){ // pressing the RIGHT button goes into automatic mode
          statemachine.d = statemachine.ADDER;
        }
        
        if(io_dip[23]){ // flipping the leftmost DIP switch to ON goes into manual mode
          seg.values = {8h15, 8h0, 8h0, 8h0};
          statemachine.d = statemachine.MANUAL;
        }
    // manual inputs  
      statemachine.MANUAL:
        io_led[23] = b1; // light up the LED to show that we are in manual mode
        
        if(io_button[0]){ // when top button is pressed, write the value of io_dip[15:0] to a
          a[15:0] = io_dip[15:0];
          register_a.d = a;
          register_result.d = a;
        }
        
        if(io_button[1]){ // when the center button is pressed, write the value of io_dip[15:0] to b
          b[15:0] = io_dip[15:0];
          register_b.d = b;
          register_result.d = b;
        }
        
        if(io_button[2]){ // when the down button is pressed, do the necessary computations based on a, b and ALUFN code on io_dip[21:16]
          alufn = io_dip[21:16];
          register_alufn.d = alufn;
          alutop.alufn = register_alufn.q;
          alutop.a = register_a.q;
          alutop.b = register_b.q;
          alutop.alufn = register_alufn.q;
          alu = alutop.result;
          
          register_z.d = alutop.z;
          register_v.d = alutop.v;
          register_n.d = alutop.n;
          
          register_result.d = alu[15:0];
        }
        
        if(io_button[3]){ // LEFT button resets everything
          register_a.d = 16b0;
          register_b.d = 16b0;
          register_alufn.d = 6b0;
          register_result.d = 16b0;
          register_z.d = b0;
          register_v.d = b0;
          register_n.d = b0;
        }
        
        io_led[15:0] = register_result.q; // displays the previous value entered
        
        //show z,v,n value on seven segments - display order: [- Z V N]
        if(register_z.q == b1){ //if z is true
          seg.values[2] = h1;
        }else{
          seg.values[2] = h0;
        }
        
        if(register_v.q == b1){ //if v is true
          seg.values[1] = h1;
        }else{
          seg.values[1] = h0;
        }
        
        if(register_n.q == b1){ //if n is true
          seg.values[0] = h1;
        }else{
          seg.values[0] = h0;
        }
        
        io_led[21:16] = register_alufn.q; // reflect alufn value on leds, just a visual thing
        
        if(!io_dip[23]){ //when we switch io_dip[23] to off, change to initial mode
          register_a.d = 16b0;
          register_b.d = 16b0;
          register_alufn.d = 6b0;
          register_result.d = 16b0;
          register_z.d = b0;
          register_v.d = b0;
          register_n.d = b0;
          statemachine.d = statemachine.INITIAL;
        }
      // manual mode ends here
        
      // test cases start here - the test cases are run in the order that they are written      
      statemachine.ADDER:
      // does addition without overflow
        register_alufn.d = 6b0;
        register_a.d = 16b0000000000000101; //a = 5
        register_b.d = 16b0000000000000011; //b = 3
        register_correct.d = 16b0000000000001000; //expected result: 8
        
        alutop.alufn = register_alufn.q;
        alutop.a = register_a.q;
        alutop.b = register_b.q;
        alu = alutop.result;
        
        register_z.d = alutop.z;
        register_v.d = alutop.v;
        register_n.d = alutop.n;
        
        if(case_state.q == 0){
          seg.values = {8h1, 8hf, 8hf, 8hf}; // "1"
          register_status.d = c{2b0, register_alufn.q};
          register_result.d = 16b0;
        }
        
        if (case_state.q == 1){
          seg.values = {8he, 8hf, 8hf, 8hf};   //  "A"                    
          register_status.d = 6b0;                                         // clear io_led[23:16]
          register_result.d = register_a.q;                                    // show value of A in leds
        }
          
        if (case_state.q == 2){
          seg.values = {8h8, 8hf, 8hf, 8hf};          // io_seg: "   B"
          register_result.d = register_b.q;                                     // show value of B in leds
        }
          
        if (case_state.q == 3){
          register_status.d = c{5b0, register_z.q, register_v.q, register_n.q};   // Show 00000ZVN on io_led[23:16]
          register_result.d = alu[15:0];                                   // show the ALU RESULT
          
          if (register_correct.q == alu[15:0]){                             // Compare expected correct result & the alu result
            seg.values = {8hd, 8he, 8h5, 8h5};                         // "PASS"
          } else {
            seg.values = {8hd, 8he, 8h5, 8h5};                         // "FAIL"
          }
        }
        
        if (case_state.q == 4){                                         // Transition to next operation case
          register_a.d = 16b0;                                           // Clear all stored value
          register_b.d = 16b0;
          register_alufn.d = 6b0;
          register_status.d = 8b0;
          register_result.d = 16b0;
          register_z.d = b0;
          register_v.d = b0;
          register_n.d = b0;
          case_state.d = 0;
          statemachine.d = statemachine.ADDEROV; 
          }
        
         io_led[23:16] = register_status.q;   // Show what is stored in store_status.q - can be ALUFN[5:0] or 000ZVN
         io_led[15:0] = register_result.q;      // Show what is stored in store_temp.q - can be either A[15:0] or B[15:0] depending on inner case_state 
          
          
        // If triggered back to MANUAL STATE      
        if(io_dip[23]){                   //checking switch for manual state
          statemachine.d = statemachine.MANUAL;}
            
        // In charge of counters & inner change of state      
        counter.d = counter.q+1;                    //add 1 to clock every time code loops
        if(io_button[3] | counter.q[TIMER]==1){
          case_state.d = case_state.q+1;         //if clock timer reaches TIMER or if button input is detected
          counter.d = 0;
        }
        
        //ADDER with overflow
      statemachine.ADDEROV:
        register_alufn.d = 6b0;
        register_a.d = 16b0111111111111111; //a
        register_b.d = 16b0111111111111111; //b
        register_correct.d = 16b1111111111111110; //expected result 
        
        alutop.alufn = register_alufn.q;
        alutop.a = register_a.q;
        alutop.b = register_b.q;
        alu = alutop.result;
        
        register_z.d = alutop.z;
        register_v.d = alutop.v;
        register_n.d = alutop.n;
        
        if(case_state.q == 0){
          seg.values = {8h2, 8hf, 8hf, 8hf}; // "2"
          register_status.d = c{2b0, register_alufn.q};
          register_result.d = 16b0;
        }
        
        if (case_state.q == 1){
          seg.values = {8he, 8hf, 8hf, 8hf};  //"A"                      
          register_status.d = 6b0;                                         // clear io_led[23:16]
          register_result.d = register_a.q;                                    // show value of A in leds
        }
          
        if (case_state.q == 2){
          seg.values = {8h8, 8hf, 8hf, 8hf};                         // io_seg: "   B"
          register_result.d = register_b.q;                                     // show value of B in leds
        }
          
        if (case_state.q == 3){
          register_status.d = c{5b0, register_z.q, register_v.q, register_n.q};   // Show 00000ZVN on io_led[23:16]
          register_result.d = alu[15:0];                                   // show the ALU RESULT
          
          if (register_correct.q == alu[15:0]){                             // Compare expected correct result & the alu result
            seg.values = {8hd, 8he, 8h5, 8h5};                         // "PASS"
          } else {
            seg.values = {8ha, 8he, 8hb, 8hc} ;                         // "FAIL"
          }
        }
        
        if (case_state.q == 4){                                         // Transition to next operation case
          register_a.d = 16b0;                                           // Clear all stored value
          register_b.d = 16b0;
          register_alufn.d = 6b0;
          register_status.d = 8b0;
          register_result.d = 16b0;
          register_z.d = b0;
          register_v.d = b0;
          register_n.d = b0;
          case_state.d = 0;
          statemachine.d = statemachine.COMPAREEQ; 
          }
        
         io_led[23:16] = register_status.q;   // Show what is stored in store_status.q - can be ALUFN[5:0] or 000ZVN
         io_led[15:0] = register_result.q;      // Show what is stored in store_temp.q - can be either A[15:0] or B[15:0] depending on inner case_state 
          
          
        // If triggered back to MANUAL STATE      
        if(io_dip[23]){                   //checking switch for manual state
          statemachine.d = statemachine.MANUAL;}
            
        // In charge of counters & inner change of state      
        counter.d = counter.q+1;                    //add 1 to clock every time code loops
        if(io_button[3] | counter.q[TIMER]==1){
          case_state.d = case_state.q+1;         //if clock timer reaches TIMER or if button input is detected
          counter.d = 0;
        }
      
      //COMPARE EQUAL
      statemachine.COMPAREEQ:
        register_alufn.d = 6b110011;
        register_a.d = 16b0000000010000000; //a = 128
        register_b.d = 16b0000000010000000; //b - 128
        register_correct.d = 16b0000000000000001; //expected result: TRUE, they are equal
        
        alutop.alufn = register_alufn.q;
        alutop.a = register_a.q;
        alutop.b = register_b.q;
        alu = alutop.result;
        
        register_z.d = alutop.z;
        register_v.d = alutop.v;
        register_n.d = alutop.n;
        
        if(case_state.q == 0){
          seg.values = {8h3, 8hf, 8hf, 8hf}; // "3"
          register_status.d = c{2b0, register_alufn.q};
          register_result.d = 16b0;
        }
        
        if (case_state.q == 1){
          seg.values = {8he, 8hf, 8hf, 8hf};  //"A"                      
          register_status.d = 6b0;                                         // clear io_led[23:16]
          register_result.d = register_a.q;                                    // show value of A in leds
        }
          
        if (case_state.q == 2){
          seg.values = {8h8, 8hf, 8hf, 8hf};                         // io_seg: "   B"
          register_result.d = register_b.q;                                     // show value of B in leds
        }
          
        if (case_state.q == 3){
          register_status.d = c{5b0, register_z.q, register_v.q, register_n.q};   // Show 00000ZVN on io_led[23:16]
          register_result.d = alu[15:0];                                   // show the ALU RESULT
          
          if (register_correct.q == alu[15:0]){                             // Compare expected correct result & the alu result
            seg.values = {8hd, 8he, 8h5, 8h5};                         // "PASS"
          } else {
            seg.values = {8ha, 8he, 8hb, 8hc} ;                         // "FAIL"
          }
        }
        
        if (case_state.q == 4){                                         // Transition to next operation case
          register_a.d = 16b0;                                           // Clear all stored value
          register_b.d = 16b0;
          register_alufn.d = 6b0;
          register_status.d = 8b0;
          register_result.d = 16b0;
          register_z.d = b0;
          register_v.d = b0;
          register_n.d = b0;
          case_state.d = 0;
          statemachine.d = statemachine.COMPARELT; 
          }
        
         io_led[23:16] = register_status.q;   // Show what is stored in store_status.q - can be ALUFN[5:0] or 000ZVN
         io_led[15:0] = register_result.q;      // Show what is stored in store_temp.q - can be either A[15:0] or B[15:0] depending on inner case_state 
          
          
        // If triggered back to MANUAL STATE      
        if(io_dip[23]){                   //checking switch for manual state
          statemachine.d = statemachine.MANUAL;}
            
        // In charge of counters & inner change of state      
        counter.d = counter.q+1;                    //add 1 to clock every time code loops
        if(io_button[3] | counter.q[TIMER]==1){
          case_state.d = case_state.q+1;         //if clock timer reaches TIMER or if button input is detected
          counter.d = 0;
        }
        
        //COMPARE LESS THAN
      statemachine.COMPARELT:
        register_alufn.d = 6b111101;
        register_a.d = 16b0000000000000001; //a = 1
        register_b.d = 16b0000000000001010; //b = 10
        register_correct.d = 16b0000000000000001; //expected result = TRUE, a < b
        
        alutop.alufn = register_alufn.q;
        alutop.a = register_a.q;
        alutop.b = register_b.q;
        alu = alutop.result;
        
        register_z.d = alutop.z;
        register_v.d = alutop.v;
        register_n.d = alutop.n;
        
        if(case_state.q == 0){
          seg.values = {8h4, 8hf, 8hf, 8hf}; // "4"
          register_status.d = c{2b0, register_alufn.q};
          register_result.d = 16b0;
        }
        
        if (case_state.q == 1){
          seg.values = {8he, 8hf, 8hf, 8hf};  //"A" 
          register_status.d = 6b0;                                         // clear io_led[23:16]
          register_result.d = register_a.q;                                    // show value of A in leds
        }
          
        if (case_state.q == 2){
          seg.values = {8h8, 8hf, 8hf, 8hf};                         // io_seg: "   B"
          register_result.d = register_b.q;                                     // show value of B in leds
        }
          
        if (case_state.q == 3){
          register_status.d = c{5b0, register_z.q, register_v.q, register_n.q};   // Show 00000ZVN on io_led[23:16]
          register_result.d = alu[15:0];                                   // show the ALU RESULT
          
          if (register_correct.q == alu[15:0]){                             // Compare expected correct result & the alu result
            seg.values = {8hd, 8he, 8h5, 8h5};                         // "PASS"
          } else {
            seg.values = {8ha, 8he, 8hb, 8hc} ;                         // "FAIL"
          }
        }
        
        if (case_state.q == 4){                                         // Transition to next operation case
          register_a.d = 16b0;                                           // Clear all stored value
          register_b.d = 16b0;
          register_alufn.d = 6b0;
          register_status.d = 8b0;
          register_result.d = 16b0;
          register_z.d = b0;
          register_v.d = b0;
          register_n.d = b0;
          case_state.d = 0;
          statemachine.d = statemachine.BOOLAND; 
          }
        
         io_led[23:16] = register_status.q;   // Show what is stored in store_status.q - can be ALUFN[5:0] or 000ZVN
         io_led[15:0] = register_result.q;      // Show what is stored in store_temp.q - can be either A[15:0] or B[15:0] depending on inner case_state 
          
          
        // If triggered back to MANUAL STATE      
        if(io_dip[23]){                   //checking switch for manual state
          statemachine.d = statemachine.MANUAL;}
            
        // In charge of counters & inner change of state      
        counter.d = counter.q+1;                    //add 1 to clock every time code loops
        if(io_button[3] | counter.q[TIMER]==1){
          case_state.d = case_state.q+1;         //if clock timer reaches TIMER or if button input is detected
          counter.d = 0;
        }      
        
        //BITWISE AND
        statemachine.BOOLAND:
        register_alufn.d = 6b010001;
        register_a.d = 16b1111111100000000; //a
        register_b.d = 16b0000111100001111; //b = 10
        register_correct.d = 16b0000111100000000; //expected result 
        
        alutop.alufn = register_alufn.q;
        alutop.a = register_a.q;
        alutop.b = register_b.q;
        alu = alutop.result;
        
        register_z.d = alutop.z;
        register_v.d = alutop.v;
        register_n.d = alutop.n;
        
       
        if(case_state.q == 0){
          seg.values = {8h5, 8hf, 8hf, 8hf}; // "5"
          register_status.d = c{2b0, register_alufn.q};
          register_result.d = 16b0;
        }
        
        if (case_state.q == 1){
          seg.values = {8he, 8hf, 8hf, 8hf};  //"A" 
          register_status.d = 6b0;                                         // clear io_led[23:16]
          register_result.d = register_a.q;                                    // show value of A in leds
        }
          
        if (case_state.q == 2){
          seg.values = {8h8, 8hf, 8hf, 8hf};                         // io_seg: "   B"
          register_result.d = register_b.q;                                     // show value of B in leds
        }
          
        if (case_state.q == 3){
          register_status.d = c{5b0, register_z.q, register_v.q, register_n.q};   // Show 00000ZVN on io_led[23:16]
          register_result.d = alu[15:0];                                   // show the ALU RESULT
          
          if (register_correct.q == alu[15:0]){                             // Compare expected correct result & the alu result
            seg.values = {8hd, 8he, 8h5, 8h5};                         // "PASS"
          } else {
            seg.values = {8ha, 8he, 8hb, 8hc} ;                         // "FAIL"
          }
        }
        
        if (case_state.q == 4){                                         // Transition to next operation case
          register_a.d = 16b0;                                           // Clear all stored value
          register_b.d = 16b0;
          register_alufn.d = 6b0;
          register_status.d = 8b0;
          register_result.d = 16b0;
          register_z.d = b0;
          register_v.d = b0;
          register_n.d = b0;
          case_state.d = 0;
          statemachine.d = statemachine.BOOLXNOR; 
          }
        
         io_led[23:16] = register_status.q;   // Show what is stored in register_status.q - can be ALUFN[5:0] or 000ZVN
         io_led[15:0] = register_result.q;      // Show what is stored in register_temp.q - can be either A[15:0] or B[15:0] depending on inner case_state 
          
          
        // If triggered back to MANUAL STATE      
        if(io_dip[23]){                   //checking switch for manual state
          statemachine.d = statemachine.MANUAL;}
            
        // In charge of counters & inner change of state      
        counter.d = counter.q+1;                    //add 1 to clock every time code loops
        if(io_button[3] | counter.q[TIMER]==1){
          case_state.d = case_state.q+1;         //if clock timer reaches TIMER or if button input is detected
          counter.d = 0;
        }
     
     //XNOR
     statemachine.BOOLXNOR:
        register_alufn.d = 6b011010;
        register_a.d = 16b1110010101001011; //a
        register_b.d = 16b1010010101001010; //b
        register_correct.d = 16b1011111111111110; //expected result 
        
        alutop.alufn = register_alufn.q;
        alutop.a = register_a.q;
        alutop.b = register_b.q;
        alu = alutop.result;
        
        register_z.d = alutop.z;
        register_v.d = alutop.v;
        register_n.d = alutop.n;
        
        if(case_state.q == 0){
          seg.values = {8h6, 8hf, 8hf, 8hf}; // "6"
          register_status.d = c{2b0, register_alufn.q};
          register_result.d = 16b0;
        }
        
        if (case_state.q == 1){
          seg.values = {8he, 8hf, 8hf, 8hf};  //"A"                      
          register_status.d = 6b0;                                         // clear io_led[23:16]
          register_result.d = register_a.q;                                    // show value of A in leds
        }
          
        if (case_state.q == 2){
          seg.values = {8h8, 8hf, 8hf, 8hf};                         // io_seg: "   B"
          register_result.d = register_b.q;                                     // show value of B in leds
        }
          
        if (case_state.q == 3){
          register_status.d = c{5b0, register_z.q, register_v.q, register_n.q};   // Show 00000ZVN on io_led[23:16]
          register_result.d = alu[15:0];                                   // show the ALU RESULT
          
          if (register_correct.q == alu[15:0]){                             // Compare expected correct result & the alu result
            seg.values = {8hd, 8he, 8h5, 8h5};                         // "PASS"
          } else {
            seg.values = {8ha, 8he, 8hb, 8hc} ;                         // "FAIL"
          }
        }
        
        if (case_state.q == 4){                                         // Transition to next operation case
          register_a.d = 16b0;                                           // Clear all stored value
          register_b.d = 16b0;
          register_alufn.d = 6b0;
          register_status.d = 8b0;
          register_result.d = 16b0;
          register_z.d = b0;
          register_v.d = b0;
          register_n.d = b0;
          case_state.d = 0;
          statemachine.d = statemachine.SHIFTLEFT; 
          }
        
         io_led[23:16] = register_status.q;   // Show what is stored in store_status.q - can be ALUFN[5:0] or 000ZVN
         io_led[15:0] = register_result.q;      // Show what is stored in store_temp.q - can be either A[15:0] or B[15:0] depending on inner case_state 
          
          
        // If triggered back to MANUAL STATE      
        if(io_dip[23]){                   //checking switch for manual state
          statemachine.d = statemachine.MANUAL;}
            
        // In charge of counters & inner change of state      
        counter.d = counter.q+1;                    //add 1 to clock every time code loops
        if(io_button[3] | counter.q[TIMER]==1){
          case_state.d = case_state.q+1;         //if clock timer reaches TIMER or if button input is detected
          counter.d = 0;
        }   
           
     //SHIFT LEFT UNSIGNED 
     statemachine.SHIFTLEFT:
        register_alufn.d = 6b100000;
        register_a.d = 16b1111111100000000; //a
        register_b.d = 16b0011000000000011; //b : demonstrate only bottom 4 bits matter by throwing in extra 1's 
        register_correct.d = 16b1111100000000000; //expected result 
        
        alutop.alufn = register_alufn.q;
        alutop.a = register_a.q;
        alutop.b = register_b.q;
        alu = alutop.result;
        
        register_z.d = alutop.z;
        register_v.d = alutop.v;
        register_n.d = alutop.n;
        
       
        if(case_state.q == 0){
          seg.values = {8h7, 8hf, 8hf, 8hf}; // "7"
          register_status.d = c{2b0, register_alufn.q};
          register_result.d = 16b0;
        }
        
        if (case_state.q == 1){
          seg.values = {8he, 8hf, 8hf, 8hf};  //"A" 
          register_status.d = 6b0;                                         // clear io_led[23:16]
          register_result.d = register_a.q;                                    // show value of A in leds
        }
          
        if (case_state.q == 2){
          seg.values = {8h8, 8hf, 8hf, 8hf};                         // io_seg: "   B"
          register_result.d = register_b.q;                                     // show value of B in leds
        }
          
        if (case_state.q == 3){
          register_status.d = c{5b0, register_z.q, register_v.q, register_n.q};   // Show 00000ZVN on io_led[23:16]
          register_result.d = alu[15:0];                                   // show the ALU RESULT
          
          if (register_correct.q == alu[15:0]){                             // Compare expected correct result & the alu result
            seg.values = {8hd, 8he, 8h5, 8h5};                         // "PASS"
          } else {
            seg.values = {8ha, 8he, 8hb, 8hc} ;                         // "FAIL"
          }
        }
        
        if (case_state.q == 4){                                         // Transition to next operation case
          register_a.d = 16b0;                                           // Clear all stored value
          register_b.d = 16b0;
          register_alufn.d = 6b0;
          register_status.d = 8b0;
          register_result.d = 16b0;
          register_z.d = b0;
          register_v.d = b0;
          register_n.d = b0;
          case_state.d = 0;
          statemachine.d = statemachine.SHIFTRIGHTA; 
          }
        
         io_led[23:16] = register_status.q;   // Show what is stored in register_status.q - can be ALUFN[5:0] or 000ZVN
         io_led[15:0] = register_result.q;      // Show what is stored in register_temp.q - can be either A[15:0] or B[15:0] depending on inner case_state 
          
          
        // If triggered back to MANUAL STATE      
        if(io_dip[23]){                   //checking switch for manual state
          statemachine.d = statemachine.MANUAL;}
            
        // In charge of counters & inner change of state      
        counter.d = counter.q+1;                    //add 1 to clock every time code loops
        if(io_button[3] | counter.q[TIMER]==1){
          case_state.d = case_state.q+1;         //if clock timer reaches TIMER or if button input is detected
          counter.d = 0;
        }
      //SRA
      statemachine.SHIFTRIGHTA:
        register_alufn.d = 6b100011;
        register_a.d = 16b1010011111111111; //a
        register_b.d = 16b0000000000000001; //b
        register_correct.d = 16b1101001111111111; //expected result 
        
        alutop.alufn = register_alufn.q;
        alutop.a = register_a.q;
        alutop.b = register_b.q;
        alu = alutop.result;
        
        register_z.d = alutop.z;
        register_v.d = alutop.v;
        register_n.d = alutop.n;
        
        if(case_state.q == 0){
          seg.values = {8h8, 8hf, 8hf, 8hf}; // "8"
          register_status.d = c{2b0, register_alufn.q};
          register_result.d = 16b0;
        }
        
        if (case_state.q == 1){
          seg.values = {8he, 8hf, 8hf, 8hf};  //"A"                      
          register_status.d = 6b0;                                         // clear io_led[23:16]
          register_result.d = register_a.q;                                    // show value of A in leds
        }
          
        if (case_state.q == 2){
          seg.values = {8h8, 8hf, 8hf, 8hf};                         // io_seg: "   B"
          register_result.d = register_b.q;                                     // show value of B in leds
        }
          
        if (case_state.q == 3){
          register_status.d = c{5b0, register_z.q, register_v.q, register_n.q};   // Show 00000ZVN on io_led[23:16]
          register_result.d = alu[15:0];                                   // show the ALU RESULT
          
          if (register_correct.q == alu[15:0]){                             // Compare expected correct result & the alu result
            seg.values = {8hd, 8he, 8h5, 8h5};                         // "PASS"
          } else {
            seg.values = {8ha, 8he, 8hb, 8hc} ;                         // "FAIL"
          }
        }
        
        if (case_state.q == 4){                                         // Transition to next operation case
          register_a.d = 16b0;                                           // Clear all stored value
          register_b.d = 16b0;
          register_alufn.d = 6b0;
          register_status.d = 8b0;
          register_result.d = 16b0;
          register_z.d = b0;
          register_v.d = b0;
          register_n.d = b0;
          case_state.d = 0;
          statemachine.d = statemachine.SHOWB; 
          }
        
         io_led[23:16] = register_status.q;   // Show what is stored in store_status.q - can be ALUFN[5:0] or 000ZVN
         io_led[15:0] = register_result.q;      // Show what is stored in store_temp.q - can be either A[15:0] or B[15:0] depending on inner case_state 
          
          
        // If triggered back to MANUAL STATE      
        if(io_dip[23]){                   //checking switch for manual state
          statemachine.d = statemachine.MANUAL;}
            
        // In charge of counters & inner change of state      
        counter.d = counter.q+1;                    //add 1 to clock every time code loops
        if(io_button[3] | counter.q[TIMER]==1){
          case_state.d = case_state.q+1;         //if clock timer reaches TIMER or if button input is detected
          counter.d = 0;
        }
      
        
      //SHOW B
      statemachine.SHOWB:
        register_alufn.d = 6b010100;
        register_a.d = 16b1111111111111111; //a
        register_b.d = 16b0000000000101010; //b
        register_correct.d = 16b0000000000101010; //expected result 
        
        alutop.alufn = register_alufn.q;
        alutop.a = register_a.q;
        alutop.b = register_b.q;
        alu = alutop.result;
        
        register_z.d = alutop.z;
        register_v.d = alutop.v;
        register_n.d = alutop.n;
        
        if(case_state.q == 0){
          seg.values = {8h9, 8hf, 8hf, 8hf}; // "9"
          register_status.d = c{2b0, register_alufn.q};
          register_result.d = 16b0;
        }
        
        if (case_state.q == 1){
          seg.values = {8he, 8hf, 8hf, 8hf};  //"A"                      
          register_status.d = 6b0;                                         // clear io_led[23:16]
          register_result.d = register_a.q;                                    // show value of A in leds
        }
          
        if (case_state.q == 2){
          seg.values = {8h8, 8hf, 8hf, 8hf};                         // io_seg: "B"
          register_result.d = register_b.q;                                     // show value of B in leds
        }
          
        if (case_state.q == 3){
          register_status.d = c{5b0, register_z.q, register_v.q, register_n.q};   // Show 00000ZVN on io_led[23:16]
          register_result.d = alu[15:0];                                   // show the ALU RESULT
          
          if (register_correct.q == alu[15:0]){                             // Compare expected correct result & the alu result
            seg.values = {8hd, 8he, 8h5, 8h5};                         // "PASS"
          } else {
            seg.values = {8ha, 8he, 8hb, 8hc} ;                         // "FAIL"
          }
        }
        
        if (case_state.q == 4){                                         // Transition to next operation case
          register_a.d = 16b0;                                           // Clear all stored value
          register_b.d = 16b0;
          register_alufn.d = 6b0;
          register_status.d = 8b0;
          register_result.d = 16b0;
          register_z.d = b0;
          register_v.d = b0;
          register_n.d = b0;
          case_state.d = 0;
          statemachine.d = statemachine.NOTA; 
          }
        
         io_led[23:16] = register_status.q;   // Show what is stored in store_status.q - can be ALUFN[5:0] or 000ZVN
         io_led[15:0] = register_result.q;      // Show what is stored in store_temp.q - can be either A[15:0] or B[15:0] depending on inner case_state 
          
          
        // If triggered back to MANUAL STATE      
        if(io_dip[23]){                   //checking switch for manual state
          statemachine.d = statemachine.MANUAL;}
            
        // In charge of counters & inner change of state      
        counter.d = counter.q+1;                    //add 1 to clock every time code loops
        if(io_button[3] | counter.q[TIMER]==1){
          case_state.d = case_state.q+1;         //if clock timer reaches TIMER or if button input is detected
          counter.d = 0;
        }
        
      //NOTA: negates and returns the value of A       
      statemachine.NOTA:
        register_alufn.d = 6b011011;
        register_a.d = 16b1111111100000000; //a
        register_b.d = 16b0000000000101010; //b
        register_correct.d = 16b0000000011111111; //expected result 
        
        alutop.alufn = register_alufn.q;
        alutop.a = register_a.q;
        alutop.b = register_b.q;
        alu = alutop.result;
        
        register_z.d = alutop.z;
        register_v.d = alutop.v;
        register_n.d = alutop.n;
        
        if(case_state.q == 0){
          seg.values = {8h1, 8h0, 8hf, 8hf}; // "10"
          register_status.d = c{2b0, register_alufn.q};
          register_result.d = 16b0;
        }
        
        if (case_state.q == 1){
          seg.values = {8he, 8hf, 8hf, 8hf};  //"A"                      
          register_status.d = 6b0;                                         // clear io_led[23:16]
          register_result.d = register_a.q;                                    // show value of A in leds
        }
          
        if (case_state.q == 2){
          seg.values = {8h8, 8hf, 8hf, 8hf};                         // io_seg: "   B"
          register_result.d = register_b.q;                                     // show value of B in leds
        }
          
        if (case_state.q == 3){
          register_status.d = c{5b0, register_z.q, register_v.q, register_n.q};   // Show 00000ZVN on io_led[23:16]
          register_result.d = alu[15:0];                                   // show the ALU RESULT
          
          if (register_correct.q == alu[15:0]){                             // Compare expected correct result & the alu result
            seg.values = {8hd, 8he, 8h5, 8h5};                         // "PASS"
          } else {
            seg.values = {8ha, 8he, 8hb, 8hc} ;                         // "FAIL"
          }
        }
        
        if (case_state.q == 4){                                         // Transition to next operation case
          register_a.d = 16b0;                                           // Clear all stored value
          register_b.d = 16b0;
          register_alufn.d = 6b0;
          register_status.d = 8b0;
          register_result.d = 16b0;
          register_z.d = b0;
          register_v.d = b0;
          register_n.d = b0;
          case_state.d = 0;
          statemachine.d = statemachine.MULTIPLY; 
          }
        
         io_led[23:16] = register_status.q;   // Show what is stored in store_status.q - can be ALUFN[5:0] or 000ZVN
         io_led[15:0] = register_result.q;      // Show what is stored in store_temp.q - can be either A[15:0] or B[15:0] depending on inner case_state 
          
          
        // If triggered back to MANUAL STATE      
        if(io_dip[23]){                   //checking switch for manual state
          statemachine.d = statemachine.MANUAL;}
            
        // In charge of counters & inner change of state      
        counter.d = counter.q+1;                    //add 1 to clock every time code loops
        if(io_button[3] | counter.q[TIMER]==1){
          case_state.d = case_state.q+1;         //if clock timer reaches TIMER or if button input is detected
          counter.d = 0;
        }
        
        //MULTIPLY
      statemachine.MULTIPLY:
        register_alufn.d = 6b000010;
        register_a.d = 16b0000000000000100; //a = 4
        register_b.d = 16b0000000000000100; //b = 4
        register_correct.d = 16b0000000000010000; //expected result = 16
        
        alutop.alufn = register_alufn.q;
        alutop.a = register_a.q;
        alutop.b = register_b.q;
        alu = alutop.result;
        
        register_z.d = alutop.z;
        register_v.d = alutop.v;
        register_n.d = alutop.n;
        
        if(case_state.q == 0){
          seg.values = {8h1, 8h1, 8hf, 8hf}; // "11"
          register_status.d = c{2b0, register_alufn.q};
          register_result.d = 16b0;
        }
        
        if (case_state.q == 1){
          seg.values = {8he, 8hf, 8hf, 8hf};  //"A"                      
          register_status.d = 6b0;                                         // clear io_led[23:16]
          register_result.d = register_a.q;                                    // show value of A in leds
        }
          
        if (case_state.q == 2){
          seg.values = {8h8, 8hf, 8hf, 8hf};                         // io_seg: "   B"
          register_result.d = register_b.q;                                     // show value of B in leds
        }
          
        if (case_state.q == 3){
          register_status.d = c{5b0, register_z.q, register_v.q, register_n.q};   // Show 00000ZVN on io_led[23:16]
          register_result.d = alu[15:0];                                   // show the ALU RESULT
          
          if (register_correct.q == alu[15:0]){                             // Compare expected correct result & the alu result
            seg.values = {8hd, 8he, 8h5, 8h5};                         // "PASS"
          } else {
            seg.values = {8ha, 8he, 8hb, 8hc} ;                         // "FAIL"
          }
        }
        
        if (case_state.q == 4){                                         // Transition to next operation case
          register_a.d = 16b0;                                           // Clear all stored value
          register_b.d = 16b0;
          register_alufn.d = 6b0;
          register_status.d = 8b0;
          register_result.d = 16b0;
          register_z.d = b0;
          register_v.d = b0;
          register_n.d = b0;
          case_state.d = 0;
          statemachine.d = statemachine.INITIAL; // all test cases are done, go back to initial state
          }
        
         io_led[23:16] = register_status.q;   // Show what is stored in store_status.q - can be ALUFN[5:0] or 000ZVN
         io_led[15:0] = register_result.q;      // Show what is stored in store_temp.q - can be either A[15:0] or B[15:0] depending on inner case_state 
          
          
        // If triggered back to MANUAL STATE      
        if(io_dip[23]){                   //checking switch for manual state
          statemachine.d = statemachine.MANUAL;}
            
        // In charge of counters & inner change of state      
        counter.d = counter.q+1;                    //add 1 to clock every time code loops
        if(io_button[3] | counter.q[TIMER]==1){
          case_state.d = case_state.q+1;         //if clock timer reaches TIMER or if button input is detected
          counter.d = 0;
        }
    
    }
}